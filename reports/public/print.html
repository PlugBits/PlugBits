<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PlugBits 印刷</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #f6f7fb;
        color: #111827;
      }
      .toolbar {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px 16px;
        background: #ffffff;
        border-bottom: 1px solid #e5e7eb;
        position: sticky;
        top: 0;
        z-index: 2;
      }
      .title {
        font-weight: 600;
        margin-right: auto;
      }
      .btn {
        border: none;
        border-radius: 6px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 14px;
        background: #2563eb;
        color: #fff;
      }
      .btn.secondary {
        background: #e5e7eb;
        color: #111827;
      }
      .btn[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .notice {
        margin-left: 12px;
        font-size: 12px;
        color: #6b7280;
      }
      .status {
        padding: 10px 16px;
        font-size: 14px;
        color: #374151;
      }
      .viewer {
        width: 100%;
        height: calc(100vh - 104px);
        border: none;
      }
      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="toolbar">
      <div class="title">PlugBits 印刷</div>
      <button id="printButton" class="btn secondary hidden">再試行</button>
      <button id="shareButton" class="btn hidden">共有して印刷</button>
      <button id="openButton" class="btn secondary hidden">PDFを開く</button>
      <span id="mobileNote" class="notice hidden">印刷設定は “実際のサイズ(100%)” 推奨</span>
    </div>
    <div id="status" class="status">PDFを生成中...</div>
    <iframe id="pdfFrame" class="viewer" title="PDF Preview"></iframe>

    <script>
      const params = new URLSearchParams(location.search);
      const workerBaseUrl = params.get("workerBaseUrl") || "";
      const kintoneBaseUrl = params.get("kintoneBaseUrl") || "";
      const appId = params.get("appId") || "";
      const recordId = params.get("recordId") || "";
      const templateId = params.get("templateId") || "";

      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const printButton = document.getElementById("printButton");
      const shareButton = document.getElementById("shareButton");
      const openButton = document.getElementById("openButton");
      const statusEl = document.getElementById("status");
      const pdfFrame = document.getElementById("pdfFrame");
      const mobileNote = document.getElementById("mobileNote");
      const canStart = Boolean(workerBaseUrl && templateId);

      const setStatus = (text) => {
        statusEl.textContent = text;
      };

      const showRetry = () => {
        printButton.classList.remove("hidden");
        printButton.disabled = false;
      };

      const hideRetry = () => {
        printButton.classList.add("hidden");
      };

      const normalizeOrigin = (value) => {
        try {
          return new URL(value).origin;
        } catch {
          return "";
        }
      };

      const setButtonsDisabled = (disabled) => {
        printButton.disabled = disabled;
        shareButton.disabled = disabled;
        openButton.disabled = disabled;
      };

      const shouldRetryStatus = (status) => status === 429 || status >= 500;
      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
      const baseDelayMs = 800;
      const maxRetries = 1;
      const maxStatusLogOnce = { logged: false };

      let pdfBlobUrl = "";
      let renderData = null;
      let dataReady = false;
      let inFlight = null;
      let pendingAction = null;
      let pendingWindow = null;
      let autoStarted = false;

      const markReady = (data) => {
        if (dataReady) return;
        renderData = data || {};
        dataReady = true;
        setButtonsDisabled(true);
        hideRetry();
        if (!canStart) {
          setStatus("必要なパラメータが不足しています。");
          return;
        }
        setStatus("PDFを自動生成します。");
        if (pendingAction) {
          const next = pendingAction;
          const targetWindow = pendingWindow;
          pendingAction = null;
          pendingWindow = null;
          if (next === "share") {
            return;
          }
          executeWindowAction(next, targetWindow);
        }

        if (!autoStarted) {
          autoStarted = true;
          generatePdf().then((blobUrl) => {
            if (!blobUrl) {
              showRetry();
            }
          });
        }
      };

      const generatePdf = () => {
        if (!canStart) {
          setStatus("必要なパラメータが不足しています。");
          return Promise.reject(new Error("missing params"));
        }
        if (!dataReady) {
          setStatus("印刷データを待機中...");
          return Promise.reject(new Error("data not ready"));
        }
        if (pdfBlobUrl) {
          return Promise.resolve(pdfBlobUrl);
        }
        if (inFlight) return inFlight;

        setButtonsDisabled(true);
        hideRetry();
        setStatus("PDFを生成中...");
        maxStatusLogOnce.logged = false;

        const body = {
          templateId,
          data: renderData || {},
          kintone: {
            baseUrl: kintoneBaseUrl,
            appId,
            recordId,
          },
        };

        const requestIdFrom = (res) =>
          res.headers.get("cf-ray") || res.headers.get("x-request-id") || "";
        const logOnce = (payload) => {
          if (maxStatusLogOnce.logged) return;
          maxStatusLogOnce.logged = true;
          console.info("print.html render failed", payload);
        };
        const DEBUG_PATTERN = /(^|[?#&])debug=(1|true)($|[&#])/i;
        const isDebugEnabled = () => {
          if (typeof window === "undefined") return false;
          const href = window.location.href || "";
          return DEBUG_PATTERN.test(href);
        };
        const appendDebugParam = (url, debug) => {
          if (!debug) return url;
          const base =
            typeof window !== "undefined" && window.location && window.location.origin
              ? window.location.origin
              : "http://localhost";
          let parsed;
          try {
            parsed = new URL(url, base);
          } catch {
            return url;
          }
          if (parsed.searchParams.has("debug")) return parsed.toString();
          parsed.searchParams.append("debug", "1");
          return parsed.toString();
        };
        const debugEnabled = isDebugEnabled();
        const renderUrl = appendDebugParam(
          workerBaseUrl.replace(/\/$/, "") + "/render",
          debugEnabled
        );
        if (debugEnabled) console.log("[DBG_RENDER_URL]", renderUrl);

        inFlight = (async () => {
          for (let attempt = 0; attempt <= maxRetries; attempt += 1) {
            let res;
            try {
              res = await fetch(renderUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
              });
            } catch (err) {
              if (attempt < maxRetries) {
                const waitMs =
                  baseDelayMs * 2 ** attempt + Math.floor(Math.random() * 200);
                await sleep(waitMs);
                continue;
              }
              logOnce({ error: String(err), body });
              return null;
            }

            if (res.ok) {
              const blob = await res.blob();
              pdfBlobUrl = URL.createObjectURL(blob);
              pdfFrame.src = pdfBlobUrl;
              openButton.classList.remove("hidden");
              setButtonsDisabled(false);
              pdfFrame.onload = () => {
                setStatus("PDFの準備ができました。");
              };
              return pdfBlobUrl;
            }

            const status = res.status;
            const text = await res.text().catch(() => "");
            const requestId = requestIdFrom(res);
            if (shouldRetryStatus(status) && attempt < maxRetries) {
              const waitMs =
                baseDelayMs * 2 ** attempt + Math.floor(Math.random() * 200);
              await sleep(waitMs);
              continue;
            }

            if (status === 503) {
              setStatus("サーバーが混雑しています。10秒後に再試行してください。");
            } else {
              setStatus(text || "PDF生成に失敗しました。");
            }
            logOnce({ status, requestId, body });
            showRetry();
            return null;
          }
          return null;
        })()
          .finally(() => {
            inFlight = null;
            setButtonsDisabled(!pdfBlobUrl);
          });

        return inFlight;
      };

      const executeWindowAction = async (action, targetWindow) => {
        if (!targetWindow) {
          setStatus("印刷用のタブを開けませんでした。");
          return;
        }
        const blobUrl = await generatePdf();
        if (!blobUrl) return;
        targetWindow.location.href = blobUrl;
      };

      const handleAction = async (action) => {
        if (!dataReady) {
          setStatus("印刷データを待機中...");
          if (action === "share") return;
          const w = window.open("", "_blank");
          if (!w) {
            setStatus("印刷用のタブを開けませんでした。");
            return;
          }
          pendingAction = action;
          pendingWindow = w;
          return;
        }
        if (!canStart) {
          setStatus("必要なパラメータが不足しています。");
          return;
        }

        if (action === "share") {
          if (!navigator.share) {
            setStatus("共有が利用できないため、PDFを開いてください。");
            return;
          }
          const blobUrl = await generatePdf();
          if (!blobUrl) return;
          const blob = await fetch(blobUrl).then((res) => res.blob());
          const file = new File([blob], "plugbits-report.pdf", {
            type: "application/pdf",
          });
          try {
            if (navigator.canShare && !navigator.canShare({ files: [file] })) {
              setStatus("この端末では共有が利用できません。");
              return;
            }
            await navigator.share({ files: [file], title: "PlugBits PDF" });
          } catch {
            setStatus("共有に失敗しました。PDFを開いてください。");
          }
          return;
        }

        const w = window.open("", "_blank");
        await executeWindowAction(action, w);
      };

      if (isMobile) {
        shareButton.classList.remove("hidden");
        mobileNote.classList.remove("hidden");
      }
      openButton.classList.remove("hidden");
      setButtonsDisabled(true);

      printButton.addEventListener("click", () => {
        if (!dataReady || !canStart) return;
        generatePdf();
      });
      openButton.addEventListener("click", () => handleAction("open"));
      shareButton.addEventListener("click", () => handleAction("share"));

      const dataParam = params.get("data");
      if (dataParam) {
        try {
          const decoded = decodeURIComponent(dataParam);
          markReady(JSON.parse(decoded));
        } catch {
          setStatus("PDFデータの読み込みに失敗しました。");
        }
      } else {
        const opener = window.opener;
        const kintoneOrigin = normalizeOrigin(kintoneBaseUrl);
        if (opener && kintoneOrigin) {
          window.addEventListener("message", (event) => {
            if (event.origin !== kintoneOrigin) return;
            if (event.data && event.data.type === "plugbits-print-data") {
              markReady(event.data.data || {});
            }
          });
          opener.postMessage({ type: "plugbits-print-ready" }, kintoneOrigin);
          setStatus("印刷データを待機中...");
        } else {
          markReady({});
        }
      }
    </script>
  </body>
</html>
